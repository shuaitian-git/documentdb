/*-------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All rights reserved.
 *
 * src/configuration/certs.rs
 *
 *-------------------------------------------------------------------------
 */

use std::{
    path::Path,
    process::{Command, Stdio},
    sync::Arc,
};

use crate::error::{DocumentDBError, Result};
use arc_swap::ArcSwap;
use openssl::{
    pkey::{PKey, PKeyRef, Private},
    x509::X509,
};
use serde::Deserialize;

/// Certificate file change monitoring interval in seconds
const CERT_FILES_CHANGE_WATCH_INTERVAL: u64 = 60;

/// Default certificate validity period in days for auto-generated certificates
const DEFAULT_CERT_VALIDITY_DAYS: &str = "365";

/// Default key paths for auto-generated certificates
const DEFAULT_PRIVATE_KEY_PATH: &str = "./pkey.pem";
const DEFAULT_PUBLIC_KEY_PATH: &str = "./cert.pem";

/// Certificate subject for auto-generated certificates
const DEFAULT_CERT_SUBJECT: &str = "/CN=localhost";

/// Specifies the type of certificate input configuration.
///
/// This enum determines how certificates are provided to the gateway:
/// - `PemFile`: Use existing PEM certificate and key files
/// - `PemAutoGenerated`: Auto-generate self-signed certificates if they don't exist
#[derive(Debug, Deserialize, Default, Clone, PartialEq, Eq)]
#[serde(rename_all = "PascalCase")]
pub enum CertInputType {
    /// Use existing PEM certificate and private key files
    #[default]
    PemFile,
    /// Auto-generate self-signed certificates in PEM format if they don't exist
    PemAutoGenerated,
}

/// Configuration options for certificate handling.
///
/// This struct contains the paths and type information needed to configure
/// SSL/TLS certificates for the gateway server.
#[derive(Debug, Deserialize, Default, Clone)]
#[serde(rename_all = "PascalCase")]
pub struct CertificateOptions {
    /// The type of certificate input (PEM files or auto-generation)
    pub cert_type: CertInputType,
    /// Path to the certificate file (required for PemFile type)
    pub file_path: Option<String>,
    /// Path to the private key file (required for PemFile type)
    pub key_file_path: Option<String>,
    /// Path to the CA certificate chain file (optional)
    pub ca_path: Option<String>,
}

/// Internal certificate store that manages certificate file paths.
///
/// The main difference between `CertificateStore` and `CertificateOptions` is that
/// `CertificateStore` will generate the keys (and paths to them) if `cert_type` is
/// `CertInputType::PemAutoGenerated`.
pub struct CertificateStore {
    certificate_path: String,
    private_key_path: String,
    ca_path: Option<String>,
}

impl CertificateStore {
    /// Generates RSA private key and self-signed certificate using OpenSSL commands.
    ///
    /// This function creates a new RSA private key and a self-signed X.509 certificate
    /// valid for 365 days with the subject "CN=localhost".
    ///
    /// # Arguments
    ///
    /// * `private_key_path` - Path where the private key will be saved
    /// * `public_key_path` - Path where the certificate will be saved
    ///
    /// # Returns
    ///
    /// Returns `Ok(())` on success, or an error if OpenSSL commands fail.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    /// * OpenSSL is not available in PATH
    /// * File system permissions prevent writing to the specified paths
    /// * OpenSSL command execution fails
    fn generate_auth_keys(private_key_path: &str, public_key_path: &str) -> Result<()> {
        // openssl genpkey -algorithm RSA -out private_key.pem -outform PEM
        let pkey_output = Command::new("openssl")
            .arg("genpkey")
            .args(["-algorithm", "RSA"])
            .args(["-out", private_key_path, "-outform", "PEM"])
            .stdout(Stdio::null())
            .output()?;

        if !pkey_output.status.success() {
            return Err(DocumentDBError::internal_error(format!(
                "OpenSSL failed during private key generation: '{}'",
                String::from_utf8_lossy(&pkey_output.stderr)
            )));
        }

        // openssl req -key private_key.pem -new -x509 -days 365 -out public_key.pem -outform PEM -subj "/CN=localhost"
        let pub_key_output = Command::new("openssl")
            .arg("req")
            .args(["-key", private_key_path])
            .args([
                "-new",
                "-x509",
                "-days",
                DEFAULT_CERT_VALIDITY_DAYS,
                "-out",
                public_key_path,
                "-outform",
                "PEM",
            ])
            .args(["-subj", DEFAULT_CERT_SUBJECT])
            .output()?;

        if !pub_key_output.status.success() {
            return Err(DocumentDBError::internal_error(format!(
                "OpenSSL failed during certificate generation: '{}'",
                String::from_utf8_lossy(&pub_key_output.stderr)
            )));
        }

        Ok(())
    }

    /// Creates a new certificate store from the provided options.
    ///
    /// For `PemFile` type, validates that required file paths are provided.
    /// For `PemAutoGenerated` type, generates certificates if they don't exist.
    ///
    /// # Arguments
    ///
    /// * `certificate_options` - Configuration specifying certificate type and paths
    ///
    /// # Returns
    ///
    /// Returns a configured `CertificateStore` ready for use.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    /// * Required file paths are missing for PemFile type
    /// * Certificate generation fails for auto-generation type
    /// * File system operations fail
    pub fn new(certificate_options: &CertificateOptions) -> Result<Self> {
        match certificate_options.cert_type {
            CertInputType::PemFile => {
                let certificate_path = certificate_options.file_path.as_ref().ok_or_else(|| {
                    DocumentDBError::internal_error(
                        "Certificate file path is required.".to_string(),
                    )
                })?;

                let private_key_path =
                    certificate_options.key_file_path.as_ref().ok_or_else(|| {
                        DocumentDBError::internal_error(
                            "Private key file path is required.".to_string(),
                        )
                    })?;

                Ok(Self {
                    certificate_path: certificate_path.clone(),
                    private_key_path: private_key_path.clone(),
                    ca_path: certificate_options.ca_path.clone(),
                })
            }
            CertInputType::PemAutoGenerated => {
                // We don't need to regenerate the keys if they already exist
                // One of the cases is e2e tests
                if !Path::new(DEFAULT_PRIVATE_KEY_PATH).exists()
                    || !Path::new(DEFAULT_PUBLIC_KEY_PATH).exists()
                {
                    Self::generate_auth_keys(DEFAULT_PRIVATE_KEY_PATH, DEFAULT_PUBLIC_KEY_PATH)?;
                }

                Ok(Self {
                    certificate_path: DEFAULT_PUBLIC_KEY_PATH.to_string(),
                    private_key_path: DEFAULT_PRIVATE_KEY_PATH.to_string(),
                    ca_path: None,
                })
            }
        }
    }
}

/// A bundle containing SSL/TLS certificate, private key, and CA chain.
///
/// This struct holds all the cryptographic materials needed for SSL/TLS operations,
/// including the server certificate, its private key, and any intermediate CA certificates.
pub struct CertificateBundle {
    certificate: X509,
    private_key: PKey<Private>,
    ca_chain: Vec<X509>,
}

impl CertificateBundle {
    /// Creates a certificate bundle by loading certificates from the certificate store.
    ///
    /// This async function reads certificate files from disk and parses them into
    /// the appropriate OpenSSL structures.
    ///
    /// # Arguments
    ///
    /// * `certificate_store` - The certificate store containing file paths
    ///
    /// # Returns
    ///
    /// Returns a `CertificateBundle` on success.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    /// * Certificate or private key files cannot be read
    /// * Certificate parsing fails (invalid PEM format)
    /// * CA chain file is specified but cannot be read or parsed
    pub async fn from_cert_store(certificate_store: &CertificateStore) -> Result<Self> {
        let cert_bytes = tokio::fs::read(&certificate_store.certificate_path).await?;
        let certificate = X509::from_pem(&cert_bytes)?;

        let pkey_bytes = tokio::fs::read(&certificate_store.private_key_path).await?;
        let pkey = PKey::private_key_from_pem(&pkey_bytes)?;

        let mut ca_chain = Vec::new();
        if let Some(ca_path) = &certificate_store.ca_path {
            let ca_chain_pem = tokio::fs::read(ca_path).await?;
            ca_chain = X509::stack_from_pem(&ca_chain_pem)?;
        }

        Ok(Self {
            certificate,
            private_key: pkey,
            ca_chain,
        })
    }

    /// Returns a clone of the server certificate.
    ///
    /// Note: The OpenSSL crate doesn't provide borrowing for X509 certificates,
    /// so this method returns a clone.
    ///
    /// # Returns
    ///
    /// Returns a cloned `X509` certificate.
    pub fn certificate(&self) -> X509 {
        self.certificate.clone()
    }

    /// Returns a reference to the private key.
    ///
    /// # Returns
    ///
    /// Returns a reference to the private key for use in SSL contexts.
    pub fn private_key(&self) -> &PKeyRef<Private> {
        self.private_key.as_ref()
    }

    /// Returns a slice of the CA certificate chain.
    ///
    /// # Returns
    ///
    /// Returns a slice containing all intermediate CA certificates.
    pub fn ca_chain(&self) -> &[X509] {
        &self.ca_chain
    }
}

/// A provider that manages SSL/TLS certificates with automatic reloading.
///
/// This struct handles certificate loading, monitoring for file changes, and
/// automatic reloading when certificate files are updated on disk. It runs
/// a background task that periodically checks for certificate file modifications.
pub struct CertificateProvider {
    bundle: Arc<ArcSwap<CertificateBundle>>,
}

impl CertificateProvider {
    async fn get_modified_time(path: &str) -> Result<std::time::SystemTime> {
        let metadata = tokio::fs::metadata(path).await?;
        Ok(metadata.modified()?)
    }

    /// Creates a new certificate provider with automatic certificate reloading.
    ///
    /// This function sets up the initial certificate bundle and starts a background
    /// task that monitors certificate files for changes and reloads them automatically.
    ///
    /// # Arguments
    ///
    /// * `certificate_options` - Configuration specifying certificate type and paths
    ///
    /// # Returns
    ///
    /// Returns a `CertificateProvider` that manages certificates and automatic reloading.
    ///
    /// # Errors
    ///
    /// This function will return an error if:
    /// * Initial certificate loading fails
    /// * Certificate store creation fails
    /// * File modification time cannot be determined
    pub async fn new(certificate_options: &CertificateOptions) -> Result<Self> {
        let certificate_store = CertificateStore::new(certificate_options)?;

        let bundle_as_arc = Arc::new(ArcSwap::from_pointee(
            CertificateBundle::from_cert_store(&certificate_store).await?,
        ));

        let mut last_cert_modified =
            Self::get_modified_time(&certificate_store.certificate_path).await?;
        let mut last_key_modified =
            Self::get_modified_time(&certificate_store.private_key_path).await?;
        let bundle_arc_clone = Arc::clone(&bundle_as_arc);

        tokio::spawn(async move {
            let mut certs_changed_watch = tokio::time::interval(tokio::time::Duration::from_secs(
                CERT_FILES_CHANGE_WATCH_INTERVAL,
            ));

            loop {
                certs_changed_watch.tick().await;
                if let (Ok(cert_m), Ok(key_m)) = (
                    Self::get_modified_time(&certificate_store.certificate_path).await,
                    Self::get_modified_time(&certificate_store.private_key_path).await,
                ) {
                    if cert_m > last_cert_modified || key_m > last_key_modified {
                        log::info!("Reloading TLS certificates since they have been modified.");
                        match CertificateBundle::from_cert_store(&certificate_store).await {
                            Ok(new_bundle) => {
                                bundle_arc_clone.store(Arc::new(new_bundle));
                                last_cert_modified = cert_m;
                                last_key_modified = key_m;
                                log::info!("TLS certificates reloaded.");
                            }
                            Err(e) => log::error!("Failed to reload TLS certificates: {:?}", e),
                        }
                    }
                }
            }
        });

        Ok(Self {
            bundle: bundle_as_arc,
        })
    }

    /// Returns the current certificate bundle.
    ///
    /// This method returns an atomic reference to the current certificate bundle,
    /// which may be updated by the background refresh task when certificates change.
    ///
    /// # Returns
    ///
    /// Returns an `Arc<CertificateBundle>` containing the current certificates.
    pub fn bundle(&self) -> Arc<CertificateBundle> {
        self.bundle.load().clone()
    }
}
